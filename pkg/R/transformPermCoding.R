# ----------------------------------------------------------------------------
# Generate vector for transforming opd-original to any given ordinal pattern distribution!
# ----------------------------------------------------------------------------
# the "natural" coding scheme of my function is generate_kellerperm_matrix_Olivares!
# INPUTS: 
# ndemb: Embedding dimension for time series
# target_pattern: either a character vector specifying the target pattern, 
# or a numeric matrix, which contains a self-constructed permutation coding scheme!
# OUTPUT: a numeric vector that contains the indices for changing the ordering for the ordinal pattern distribution!

#' @title A function to generate a vector from an index-transformation vector from a permutation coding scheme
#' @export
#' @description Generates a position vector to change the ordinal pattern distribution in the default permutation coding scheme (i.e. generated by ordinal_pattern_distribution(x, ndemb)) into a user-specified coding scheme. This is a required input for the function changePermCodingOPD.
#' @usage transformPermCoding(target_pattern = "lehmerperm", ndemb = 4)
#' @param target_pattern A numeric matrix that specifies the pattern to be transformed into the position vector. 
#' @param ndemb Embedding dimension of the ordinal patterns (i.e. sliding window size). Should be chosen such as length(x) >> ndemb
#' @details 
#' This function returns a character vector to transform the output of ordinal_pattern_distribution (permutation coding as of Keller and Sinn, 2005) into a user-specified permutation coding scheme.
#' For example, pattern #5 in "lehmerperm" (ndemb = 5) is given by the ranks c(0, 1, 4, 2, 3). This corresponds to pattern #41 in the (original) Keller coding scheme, as given by transformPermCoding(target_pattern = "lehmerperm", ndemb = 5)[5].
#' @return A numeric vector of length factorial(ndemb), which contains the positions of the corresponding patterns in the Keller Coding scheme. 
#' @references see e.g. Olivares et al. 2012
#' @author Sebastian Sippel
#' @examples
#' transformPermCoding(target_pattern = "lehmerperm", ndemb = 4)
transformPermCoding <- function(target_pattern = NA, ndemb) {
  
  if (is.numeric(target_pattern) && is.matrix(target_pattern) && (dim(target_pattern) == c(factorial(ndemb), ndemb))) {
    pattern = target_pattern
  } else {
    print("A valid option for 'target_pattern' must be supplied!")
    return(NA)
  }
  transform_vec = sapply(1:factorial(ndemb), FUN=function(i) which(ordinal_pattern_distribution(pattern[i,], ndemb=dim(pattern)[2]) == 1))
  return(transform_vec)
}




# Generate NEW pattern coding schemes:
# ----------------------------------------------------------------------------
adjust_pattern <- function(pattern_matrix, adjustment = "jumps") {
  if (adjustment == "jumps") {
    patterns_njumps = njumps(pattern_matrix)
    sort.idx = sort.int(x=patterns_njumps, decreasing=F, index.return=T)$ix
  } else if  (adjustment == "bitflips") {
    # sort based on patterns_nbitflips:
    patterns_nbitflips <- findinversions(pattern_matrix)
    sort.idx = sort.int(x=patterns_nbitflips, decreasing=F, index.return=T)$ix
  }
  return(t(sapply(sort.idx, FUN=function(idx) pattern_matrix[idx,])))
}



# -------------------------------
# FOR INTERNAL USE
# -------------------------------
# converts ranks to permutations (and back!)
# write description !!
rank_to_permutation <- function(pattern, permutation.notation = "Olivares.2012") {
  
  n = length(pattern)
  
  if (permutation.notation == "Olivares.2012") {
    pattern_sorted = sort(pattern, decreasing = F)
    idx = sapply(X=1:n, FUN=function(i) which(pattern==pattern_sorted[i]) - 1)
  } else if (permutation.notation == "Keller.2005") {
    pattern_sorted = sort(pattern, decreasing = T)
    idx = sapply(X=1:n, FUN=function(i) n - which(pattern==pattern_sorted[i]))
  }
  return(idx)
}
# "backwards compatibility":
# -----------------------------
# rank.to.permutation is completely backwards compatible.
# checked, 12.01.2016, Sebastian Sippel
# lehmerperm = generateCodingScheme(target_pattern="lehmerperm", ndemb=4)
# lehmerperm_ranks = t(apply(X=lehmerperm, MARGIN=1, FUN=rank.to.permutation))
# lehmerperm_backwards = t(apply(X=lehmerperm_ranks, MARGIN=1, FUN=rank.to.permutation))
# any(!(lehmerperm == lehmerperm_backwards))


# Generate Lehmer matrix following Olivares et al 2012:
# write description !
generate_lehmerperm_matrix <- function(N) {
  return(t(sapply(1:factorial(N), FUN=function(x) lehmerperm(N=N, M = x) - 1)))
}



